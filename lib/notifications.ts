import { PrismaClient } from '@prisma/client'
import { formatPrice } from './utils'

const prisma = new PrismaClient()

// Tipo definido manualmente para coincidir con el schema de Prisma
export type NotificationType = 
  | 'NEW_ORDER'
  | 'ORDER_MODIFIED'
  | 'ORDER_CANCELLED'
  | 'ORDER_STATUS_CHANGED'
  | 'ORDER_CONFIRMED'
  | 'ORDER_COMPLETED'
  | 'ORDER_RECEIVED'
  | 'PAYMENT_RECEIVED'
  | 'CHAT_MESSAGE'
  | 'RETURN_REQUEST'
  | 'RETURN_APPROVED'
  | 'RETURN_REJECTED'
  | 'QUOTE_CREATED'
  | 'QUOTE_UPDATED'
  | 'QUOTE_SENT'
  | 'QUOTE_ACCEPTED'
  | 'QUOTE_REJECTED'
  | 'CREDIT_NOTE_ISSUED'
  | 'LOW_STOCK_ALERT'

interface CreateNotificationParams {
  sellerId?: string    // Para notificaciones al vendedor
  clientId?: string    // Para notificaciones al comprador
  type: NotificationType
  title: string
  message: string
  orderId?: string
  relatedId?: string   // ID de cotizaci√≥n, devoluci√≥n, etc.
  metadata?: Record<string, any>
}

/**
 * Crear una notificaci√≥n (puede ser para vendedor o comprador)
 */
export async function createNotification(params: CreateNotificationParams) {
  try {
    if (!params.sellerId && !params.clientId) {
      throw new Error('Debe especificar sellerId o clientId')
    }

    const notification = await prisma.notification.create({
      data: {
        sellerId: params.sellerId,
        clientId: params.clientId,
        type: params.type,
        title: params.title,
        message: params.message,
        orderId: params.orderId,
        relatedId: params.relatedId,
        ...(params.metadata && { metadata: params.metadata }),
      },
    })

    console.log('‚úÖ Notificaci√≥n creada:', {
      id: notification.id,
      type: notification.type,
      to: params.sellerId ? `Vendedor: ${params.sellerId}` : `Comprador: ${params.clientId}`,
    })

    return notification
  } catch (error) {
    console.error('‚ùå Error creando notificaci√≥n:', error)
    throw error
  }
}

/**
 * Crear notificaci√≥n cuando se crea una nueva orden
 */
export async function notifyNewOrder(
  sellerId: string,
  orderId: string,
  orderNumber: string,
  clientName: string,
  totalAmount: number
) {
  return createNotification({
    sellerId,
    type: 'NEW_ORDER',
    title: 'üõí Nueva Orden Recibida',
    message: `${clientName} ha creado una nueva orden #${orderNumber} por ${formatPrice(totalAmount)}`,
    orderId,
    metadata: {
      orderNumber,
      clientName,
      totalAmount,
    },
  })
}

/**
 * Crear notificaci√≥n para el COMPRADOR cuando crea una orden
 */
export async function notifyBuyerOrderCreated(
  clientId: string,
  orderId: string,
  orderNumber: string,
  totalAmount: number
) {
  return createNotification({
    clientId,
    type: 'ORDER_CONFIRMED',
    title: '‚úÖ Orden Creada Exitosamente',
    message: `Tu orden #${orderNumber} ha sido creada exitosamente por ${formatPrice(totalAmount)}. El vendedor la revisar√° pronto.`,
    orderId,
    metadata: {
      orderNumber,
      totalAmount,
    },
  })
}

/**
 * Crear notificaci√≥n cuando se modifica una orden
 */
export async function notifyOrderModified(
  sellerId: string,
  orderId: string,
  orderNumber: string,
  clientName: string,
  modifiedBy: string,
  changes: string[]
) {
  return createNotification({
    sellerId,
    type: 'ORDER_MODIFIED',
    title: 'üìù Orden Modificada',
    message: `${clientName} modific√≥ la orden #${orderNumber}. Cambios: ${changes.join(', ')}`,
    orderId,
    metadata: {
      orderNumber,
      clientName,
      modifiedBy,
      changes,
    },
  })
}

/**
 * Crear notificaci√≥n cuando se cancela una orden
 */
export async function notifyOrderCancelled(
  sellerId: string,
  orderId: string,
  orderNumber: string,
  clientName: string,
  reason?: string
) {
  return createNotification({
    sellerId,
    type: 'ORDER_CANCELLED',
    title: '‚ùå Orden Cancelada',
    message: `${clientName} cancel√≥ la orden #${orderNumber}${reason ? `. Raz√≥n: ${reason}` : ''}`,
    orderId,
    metadata: {
      orderNumber,
      clientName,
      reason,
    },
  })
}

/**
 * Crear notificaci√≥n para mensaje de chat
 */
export async function notifyChatMessage(
  sellerId: string,
  clientName: string,
  message: string
) {
  return createNotification({
    sellerId,
    type: 'CHAT_MESSAGE',
    title: 'üí¨ Nuevo Mensaje',
    message: `${clientName}: ${message.substring(0, 50)}${message.length > 50 ? '...' : ''}`,
    metadata: {
      clientName,
      messagePreview: message.substring(0, 100),
    },
  })
}

/**
 * Crear notificaci√≥n para solicitud de devoluci√≥n
 */
export async function notifyReturnRequest(
  sellerId: string,
  orderId: string,
  orderNumber: string,
  clientName: string,
  reason: string
) {
  return createNotification({
    sellerId,
    type: 'RETURN_REQUEST',
    title: '‚Ü©Ô∏è Solicitud de Devoluci√≥n',
    message: `${clientName} solicit√≥ devoluci√≥n para orden #${orderNumber}. Raz√≥n: ${reason}`,
    orderId,
    metadata: {
      orderNumber,
      clientName,
      reason,
    },
  })
}

/**
 * Obtener contador de notificaciones no le√≠das
 */
export async function getUnreadCount(sellerId?: string, clientId?: string): Promise<number> {
  try {
    const where: any = { isRead: false }
    
    if (sellerId) where.sellerId = sellerId
    if (clientId) where.clientId = clientId
    
    const count = await prisma.notification.count({ where })
    return count
  } catch (error) {
    console.error('Error getting unread count:', error)
    return 0
  }
}

// ============================================================================
// NOTIFICACIONES AL COMPRADOR (Vendedor ‚Üí Comprador)
// ============================================================================

/**
 * Notificar al comprador que su orden cambi√≥ de estado
 */
export async function notifyOrderStatusChanged(
  clientId: string,
  orderId: string,
  orderNumber: string,
  oldStatus: string,
  newStatus: string
) {
  const statusMessages: Record<string, { title: string; emoji: string }> = {
    CONFIRMED: { title: '‚úÖ Orden Confirmada', emoji: '‚úÖ' },
    IN_PROGRESS: { title: 'üîÑ Orden en Preparaci√≥n', emoji: 'üîÑ' },
    READY: { title: 'üì¶ Orden Lista', emoji: 'üì¶' },
    DELIVERED: { title: 'üöö Orden Entregada', emoji: 'üöö' },
    COMPLETED: { title: 'üéâ Orden Completada', emoji: 'üéâ' },
    CANCELLED: { title: '‚ùå Orden Cancelada', emoji: '‚ùå' },
  }

  const statusInfo = statusMessages[newStatus] || { title: 'üìã Estado Actualizado', emoji: 'üìã' }

  return createNotification({
    clientId,
    type: 'ORDER_STATUS_CHANGED',
    title: statusInfo.title,
    message: `Tu orden #${orderNumber} cambi√≥ de estado: ${oldStatus} ‚Üí ${newStatus}`,
    orderId,
    metadata: {
      orderNumber,
      oldStatus,
      newStatus,
    },
  })
}

/**
 * Notificar al comprador que su orden fue confirmada
 */
export async function notifyOrderConfirmed(
  clientId: string,
  orderId: string,
  orderNumber: string,
  estimatedDelivery?: string
) {
  return createNotification({
    clientId,
    type: 'ORDER_CONFIRMED',
    title: '‚úÖ Orden Confirmada',
    message: `Tu orden #${orderNumber} ha sido confirmada${estimatedDelivery ? `. Entrega estimada: ${estimatedDelivery}` : ''}`,
    orderId,
    metadata: {
      orderNumber,
      estimatedDelivery,
    },
  })
}

/**
 * Notificar al comprador que su orden est√° completada
 */
export async function notifyOrderCompleted(
  clientId: string,
  orderId: string,
  orderNumber: string
) {
  return createNotification({
    clientId,
    type: 'ORDER_COMPLETED',
    title: 'üéâ Orden Completada',
    message: `Tu orden #${orderNumber} ha sido completada. ¬°Gracias por tu compra!`,
    orderId,
    metadata: {
      orderNumber,
    },
  })
}

/**
 * Notificar al vendedor que el comprador recibi√≥ la orden
 */
export async function notifyOrderReceived(
  sellerId: string,
  orderId: string,
  orderNumber: string,
  clientName: string
) {
  return createNotification({
    clientId: sellerId, // Notificar al vendedor
    type: 'ORDER_RECEIVED',
    title: '‚úÖ Mercanc√≠a Recibida',
    message: `${clientName} confirm√≥ que recibi√≥ la orden #${orderNumber}`,
    orderId,
    metadata: {
      orderNumber,
      clientName,
      receivedAt: new Date().toISOString(),
    },
  })
}

/**
 * Notificar al comprador que se cre√≥ una cotizaci√≥n
 */
export async function notifyQuoteCreated(
  clientId: string,
  quoteId: string,
  quoteNumber: string,
  totalAmount: number
) {
  return createNotification({
    clientId,
    type: 'QUOTE_CREATED',
    title: 'üìã Nueva Cotizaci√≥n',
    message: `Se ha creado una cotizaci√≥n #${quoteNumber} por ${formatPrice(totalAmount)}`,
    relatedId: quoteId,
    metadata: {
      quoteNumber,
      totalAmount,
    },
  })
}

/**
 * Notificar al comprador que se actualiz√≥ una cotizaci√≥n
 */
export async function notifyQuoteUpdated(
  clientId: string,
  quoteId: string,
  quoteNumber: string,
  changes: string[]
) {
  return createNotification({
    clientId,
    type: 'QUOTE_UPDATED',
    title: 'üìù Cotizaci√≥n Actualizada',
    message: `La cotizaci√≥n #${quoteNumber} fue actualizada. Cambios: ${changes.join(', ')}`,
    relatedId: quoteId,
    metadata: {
      quoteNumber,
      changes,
    },
  })
}

/**
 * Notificar al comprador sobre aprobaci√≥n de devoluci√≥n
 */
export async function notifyReturnApproved(
  clientId: string,
  returnId: string,
  returnNumber: string,
  refundAmount: number
) {
  return createNotification({
    clientId,
    type: 'RETURN_APPROVED',
    title: '‚úÖ Devoluci√≥n Aprobada',
    message: `Tu devoluci√≥n #${returnNumber} fue aprobada. Reembolso: ${formatPrice(refundAmount)}`,
    relatedId: returnId,
    metadata: {
      returnNumber,
      amount: refundAmount, // Usar 'amount' para consistencia con el modal
    },
  })
}

/**
 * Notificar al comprador sobre rechazo de devoluci√≥n
 */
export async function notifyReturnRejected(
  clientId: string,
  returnId: string,
  returnNumber: string,
  reason: string
) {
  return createNotification({
    clientId,
    type: 'RETURN_REJECTED',
    title: '‚ùå Devoluci√≥n Rechazada',
    message: `Tu devoluci√≥n #${returnNumber} fue rechazada. Raz√≥n: ${reason}`,
    relatedId: returnId,
    metadata: {
      returnNumber,
      reason,
    },
  })
}

/**
 * Notificar al comprador sobre nota de cr√©dito
 */
export async function notifyCreditNoteIssued(
  clientId: string,
  creditNoteId: string,
  creditNoteNumber: string,
  amount: number
) {
  return createNotification({
    clientId,
    type: 'CREDIT_NOTE_ISSUED',
    title: 'üí≥ Nota de Cr√©dito Emitida',
    message: `Se emiti√≥ una nota de cr√©dito #${creditNoteNumber} por ${formatPrice(amount)}`,
    relatedId: creditNoteId,
    metadata: {
      creditNoteNumber,
      amount,
    },
  })
}

/**
 * Enviar mensaje autom√°tico al chat cuando se cancela una orden
 */
export async function sendAutomaticCancellationMessage(
  sellerId: string,
  clientAuthId: string,
  orderNumber: string,
  reason?: string
) {
  try {
    console.log('üîç Iniciando env√≠o de mensaje autom√°tico de cancelaci√≥n:', {
      sellerId,
      clientAuthId,
      orderNumber,
      reason
    })

    const now = new Date()
    const formattedDate = now.toLocaleDateString('es-ES', {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
    })
    const formattedTime = now.toLocaleTimeString('es-ES', {
      hour: '2-digit',
      minute: '2-digit',
    })

    const message = `ü§ñ ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n` +
      `   MENSAJE AUTOM√ÅTICO DEL SISTEMA\n` +
      `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n` +
      `‚ùå ORDEN CANCELADA\n\n` +
      `üì¶ Orden: #${orderNumber}\n` +
      `üìÖ Fecha: ${formattedDate}\n` +
      `üïí Hora: ${formattedTime}\n` +
      `${reason ? `\nüìù Motivo de cancelaci√≥n:\n"${reason}"\n` : '\n‚ö†Ô∏è Sin motivo especificado\n'}` +
      `\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n` +
      `‚ö° Acci√≥n requerida: Por favor, toma las medidas necesarias para procesar esta cancelaci√≥n.`

    // Verificar que el cliente existe en authenticated_users
    const clientUser = await prisma.authenticated_users.findUnique({
      where: { authId: clientAuthId },
      select: { id: true, authId: true, role: true }
    })

    if (!clientUser) {
      console.error('‚ùå Cliente no encontrado en authenticated_users:', clientAuthId)
      return
    }

    console.log('‚úÖ Cliente encontrado:', clientUser)

    // Buscar el usuario autenticado del vendedor a trav√©s de la relaci√≥n many-to-many
    // Filtrar usuarios reales de Clerk (authId empieza con "user_")
    const sellerUser = await prisma.authenticated_users.findFirst({
      where: { 
        sellers: {
          some: {
            id: sellerId
          }
        },
        authId: {
          startsWith: 'user_' // Solo usuarios reales de Clerk
        }
      },
      select: { id: true, authId: true }
    })

    if (!sellerUser?.authId) {
      console.error('‚ùå Vendedor no encontrado en authenticated_users para sellerId:', sellerId)
      return
    }

    console.log('‚úÖ Vendedor encontrado:', sellerUser)

    // Crear el mensaje en el chat usando el ID interno de authenticated_users
    const chatMessage = await prisma.chatMessage.create({
      data: {
        senderId: clientAuthId, // Clerk authId del cliente
        receiverId: sellerUser.authId, // Clerk authId del vendedor
        userId: clientUser.id, // ID interno de authenticated_users
        sellerId: sellerId, // ID del vendedor
        message,
        isRead: false,
        messageType: 'text',
        idempotencyKey: `cancel-${orderNumber}-${now.getTime()}`,
      },
    })

    console.log('‚úÖ Mensaje autom√°tico de cancelaci√≥n enviado al chat:', chatMessage.id)
  } catch (error) {
    console.error('‚ùå Error enviando mensaje autom√°tico al chat:', error)
    console.error('Stack trace:', error instanceof Error ? error.stack : 'N/A')
    // No lanzar error para no bloquear la cancelaci√≥n
  }
}
